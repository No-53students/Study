# äº¤äº’ä¼˜åŒ–å®ç°æ–¹æ¡ˆ

> æœ¬æ–‡æ¡£åŒ…å« 100 ä¸ªä¼˜åŒ–ç‚¹çš„è¯¦ç»†å®ç°æ–¹æ¡ˆï¼Œæ¶µç›– Web/iPad/iOS æµè§ˆå™¨äº¤äº’ä½“éªŒã€‚

---

## ç›®å½•

1. [è§¦æ‘¸äº¤äº’ + æ‰‹åŠ¿æ”¯æŒ](#ä¸€è§¦æ‘¸äº¤äº’--æ‰‹åŠ¿æ”¯æŒ)
2. [iPad é€‚é… + iOS ç‰¹æ€§](#äºŒipad-é€‚é…--ios-ç‰¹æ€§)
3. [åŠ¨ç”»æ•ˆæœ + å¾®äº¤äº’](#ä¸‰åŠ¨ç”»æ•ˆæœ--å¾®äº¤äº’)
4. [æ€§èƒ½ä¼˜åŒ– + å¯¼èˆªä½“éªŒ](#å››æ€§èƒ½ä¼˜åŒ–--å¯¼èˆªä½“éªŒ)

---

## ä¸€ã€è§¦æ‘¸äº¤äº’ + æ‰‹åŠ¿æ”¯æŒ

### 1.1 è§¦æ‘¸ç›®æ ‡å°ºå¯¸ä¼˜åŒ–

**é—®é¢˜**: éƒ¨åˆ†æŒ‰é’®ç‚¹å‡»åŒºåŸŸå°äº 44pxï¼Œç§»åŠ¨ç«¯éš¾ä»¥å‡†ç¡®ç‚¹å‡»

**è§£å†³æ–¹æ¡ˆ**: åˆ›å»ºç»Ÿä¸€çš„è§¦æ‘¸å‹å¥½ç»„ä»¶

```tsx
// components/ui/TouchTarget.tsx
import { cn } from "@/lib/utils";

interface TouchTargetProps {
  children: React.ReactNode;
  className?: string;
  minSize?: number; // é»˜è®¤ 48px
}

export function TouchTarget({
  children,
  className,
  minSize = 48
}: TouchTargetProps) {
  return (
    <div
      className={cn(
        "relative inline-flex items-center justify-center",
        className
      )}
      style={{ minWidth: minSize, minHeight: minSize }}
    >
      {/* æ‰©å¤§ç‚¹å‡»åŒºåŸŸçš„é€æ˜å±‚ */}
      <div
        className="absolute inset-0 -m-2"
        aria-hidden="true"
      />
      {children}
    </div>
  );
}

// ä½¿ç”¨ç¤ºä¾‹
<TouchTarget>
  <button className="w-6 h-6 rounded-full bg-zinc-800">
    <CloseIcon />
  </button>
</TouchTarget>
```

**å…¨å±€ CSS å¢å¼º**:

```css
/* globals.css */

/* ç¡®ä¿æ‰€æœ‰äº¤äº’å…ƒç´ æœ‰è¶³å¤Ÿçš„è§¦æ‘¸åŒºåŸŸ */
button,
a,
[role="button"],
input[type="checkbox"],
input[type="radio"] {
  min-height: 44px;
  min-width: 44px;
}

/* å°å‹å›¾æ ‡æŒ‰é’®ä½¿ç”¨ä¼ªå…ƒç´ æ‰©å¤§ç‚¹å‡»åŒºåŸŸ */
.touch-target-expand {
  position: relative;
}

.touch-target-expand::before {
  content: "";
  position: absolute;
  inset: -8px;
}
```

---

### 1.2 ç‚¹å‡»åé¦ˆç³»ç»Ÿ

**æ–¹æ¡ˆ A: CSS æ´»è·ƒçŠ¶æ€**

```css
/* globals.css */

/* é€šç”¨ç‚¹å‡»åé¦ˆ */
.tap-feedback {
  transition: transform 150ms ease, opacity 150ms ease;
  -webkit-tap-highlight-color: transparent;
}

.tap-feedback:active {
  transform: scale(0.97);
  opacity: 0.8;
}

/* å¡ç‰‡ç‚¹å‡»åé¦ˆ */
.card-tap {
  transition: transform 200ms cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card-tap:active {
  transform: scale(0.98);
}

/* æŒ‰é’®ç‚¹å‡»åé¦ˆ */
.btn-tap {
  transition: all 150ms ease;
}

.btn-tap:active {
  transform: scale(0.95);
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}
```

**æ–¹æ¡ˆ B: Material Design æ¶Ÿæ¼ªæ•ˆæœ**

```tsx
// components/ui/Ripple.tsx
"use client";

import { useState, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";

interface RippleProps {
  children: React.ReactNode;
  className?: string;
  color?: string;
}

interface RippleState {
  x: number;
  y: number;
  size: number;
  id: number;
}

export function Ripple({
  children,
  className,
  color = "rgba(255, 255, 255, 0.3)"
}: RippleProps) {
  const [ripples, setRipples] = useState<RippleState[]>([]);

  const handleClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height) * 2;
    const x = e.clientX - rect.left - size / 2;
    const y = e.clientY - rect.top - size / 2;

    const newRipple = { x, y, size, id: Date.now() };
    setRipples(prev => [...prev, newRipple]);

    // åŠ¨ç”»ç»“æŸåç§»é™¤
    setTimeout(() => {
      setRipples(prev => prev.filter(r => r.id !== newRipple.id));
    }, 600);
  }, []);

  return (
    <div
      className={`relative overflow-hidden ${className}`}
      onMouseDown={handleClick}
      onTouchStart={(e) => {
        const touch = e.touches[0];
        const rect = e.currentTarget.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height) * 2;
        const x = touch.clientX - rect.left - size / 2;
        const y = touch.clientY - rect.top - size / 2;
        setRipples(prev => [...prev, { x, y, size, id: Date.now() }]);
      }}
    >
      {children}
      <AnimatePresence>
        {ripples.map(ripple => (
          <motion.span
            key={ripple.id}
            initial={{ scale: 0, opacity: 0.5 }}
            animate={{ scale: 1, opacity: 0 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.6, ease: "easeOut" }}
            className="absolute rounded-full pointer-events-none"
            style={{
              left: ripple.x,
              top: ripple.y,
              width: ripple.size,
              height: ripple.size,
              backgroundColor: color,
            }}
          />
        ))}
      </AnimatePresence>
    </div>
  );
}

// ä½¿ç”¨ç¤ºä¾‹
<Ripple className="rounded-xl">
  <button className="w-full p-4 bg-emerald-600 text-white rounded-xl">
    æäº¤ç­”æ¡ˆ
  </button>
</Ripple>
```

---

### 1.3 è§¦æ‘¸å»¶è¿Ÿæ¶ˆé™¤

```css
/* globals.css */

/* æ¶ˆé™¤ 300ms è§¦æ‘¸å»¶è¿Ÿ */
html {
  touch-action: manipulation;
}

/* ç¦ç”¨åŒå‡»ç¼©æ”¾ï¼ˆä»£ç åŒºåŸŸï¼‰ */
.no-double-tap-zoom {
  touch-action: pan-x pan-y;
}

/* ç¦ç”¨é•¿æŒ‰èœå•ï¼ˆç‰¹å®šå…ƒç´ ï¼‰ */
.no-context-menu {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
```

---

### 1.4 æ‰‹åŠ¿å¯¼èˆªç³»ç»Ÿ

```tsx
// hooks/useSwipeNavigation.ts
"use client";

import { useEffect, useRef, useCallback } from "react";
import { useRouter } from "next/navigation";

interface SwipeConfig {
  threshold?: number;      // è§¦å‘é˜ˆå€¼ (px)
  edgeWidth?: number;      // è¾¹ç¼˜æ£€æµ‹å®½åº¦ (px)
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
  enableBackGesture?: boolean;
}

export function useSwipeNavigation({
  threshold = 100,
  edgeWidth = 30,
  onSwipeLeft,
  onSwipeRight,
  enableBackGesture = true,
}: SwipeConfig = {}) {
  const router = useRouter();
  const touchStartX = useRef(0);
  const touchStartY = useRef(0);
  const isEdgeSwipe = useRef(false);
  const touchMoveX = useRef(0);

  const handleTouchStart = useCallback((e: TouchEvent) => {
    const touch = e.touches[0];
    touchStartX.current = touch.clientX;
    touchStartY.current = touch.clientY;
    touchMoveX.current = 0;

    // æ£€æµ‹æ˜¯å¦ä»å·¦è¾¹ç¼˜å¼€å§‹æ»‘åŠ¨
    isEdgeSwipe.current = touch.clientX < edgeWidth;
  }, [edgeWidth]);

  const handleTouchMove = useCallback((e: TouchEvent) => {
    if (!isEdgeSwipe.current) return;

    const touch = e.touches[0];
    touchMoveX.current = touch.clientX - touchStartX.current;

    // å¯é€‰ï¼šæ˜¾ç¤ºæ»‘åŠ¨è¿›åº¦æŒ‡ç¤ºå™¨
    const progress = Math.min(touchMoveX.current / threshold, 1);
    document.documentElement.style.setProperty('--swipe-progress', String(progress));
  }, [threshold]);

  const handleTouchEnd = useCallback((e: TouchEvent) => {
    const deltaX = touchMoveX.current;
    const deltaY = e.changedTouches[0].clientY - touchStartY.current;

    // ç¡®ä¿æ˜¯æ°´å¹³æ»‘åŠ¨
    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold) {
      if (deltaX > 0 && isEdgeSwipe.current && enableBackGesture) {
        // ä»å·¦è¾¹ç¼˜å³æ»‘ -> è¿”å›
        router.back();
      } else if (deltaX > 0) {
        onSwipeRight?.();
      } else if (deltaX < 0) {
        onSwipeLeft?.();
      }
    }

    // é‡ç½®
    document.documentElement.style.removeProperty('--swipe-progress');
    isEdgeSwipe.current = false;
  }, [threshold, enableBackGesture, router, onSwipeLeft, onSwipeRight]);

  useEffect(() => {
    document.addEventListener('touchstart', handleTouchStart, { passive: true });
    document.addEventListener('touchmove', handleTouchMove, { passive: true });
    document.addEventListener('touchend', handleTouchEnd, { passive: true });

    return () => {
      document.removeEventListener('touchstart', handleTouchStart);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleTouchEnd);
    };
  }, [handleTouchStart, handleTouchMove, handleTouchEnd]);
}

// ä½¿ç”¨ç¤ºä¾‹ - åœ¨å¸ƒå±€ä¸­å¯ç”¨
// app/layout.tsx
"use client";
import { useSwipeNavigation } from "@/hooks/useSwipeNavigation";

function NavigationProvider({ children }) {
  useSwipeNavigation({
    enableBackGesture: true,
    threshold: 80,
  });

  return <>{children}</>;
}
```

---

### 1.5 æ‹–æ‹½ä¼˜åŒ–

```tsx
// components/ui/DraggableDivider.tsx
"use client";

import { useState, useCallback, useRef } from "react";

interface DraggableDividerProps {
  direction: "horizontal" | "vertical";
  onResize: (delta: number) => void;
  className?: string;
}

export function DraggableDivider({
  direction,
  onResize,
  className,
}: DraggableDividerProps) {
  const [isDragging, setIsDragging] = useState(false);
  const startPos = useRef(0);
  const dividerRef = useRef<HTMLDivElement>(null);

  const handleStart = useCallback((clientPos: number) => {
    setIsDragging(true);
    startPos.current = clientPos;
    document.body.style.cursor = direction === "horizontal" ? "col-resize" : "row-resize";
    document.body.style.userSelect = "none";
  }, [direction]);

  const handleMove = useCallback((clientPos: number) => {
    if (!isDragging) return;
    const delta = clientPos - startPos.current;
    startPos.current = clientPos;
    onResize(delta);
  }, [isDragging, onResize]);

  const handleEnd = useCallback(() => {
    setIsDragging(false);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }, []);

  // é¼ æ ‡äº‹ä»¶
  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    handleStart(direction === "horizontal" ? e.clientX : e.clientY);

    const handleMouseMove = (e: MouseEvent) => {
      handleMove(direction === "horizontal" ? e.clientX : e.clientY);
    };

    const handleMouseUp = () => {
      handleEnd();
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  };

  // è§¦æ‘¸äº‹ä»¶
  const handleTouchStart = (e: React.TouchEvent) => {
    const touch = e.touches[0];
    handleStart(direction === "horizontal" ? touch.clientX : touch.clientY);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    const touch = e.touches[0];
    handleMove(direction === "horizontal" ? touch.clientX : touch.clientY);
  };

  return (
    <div
      ref={dividerRef}
      className={`
        ${direction === "horizontal" ? "w-3 cursor-col-resize" : "h-3 cursor-row-resize"}
        flex items-center justify-center
        group
        hover:bg-emerald-500/20
        active:bg-emerald-500/30
        transition-colors
        touch-none
        ${isDragging ? "bg-emerald-500/30" : ""}
        ${className}
      `}
      onMouseDown={handleMouseDown}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleEnd}
    >
      {/* å¯è§†åŒ–æ‹–æ‹½æ‰‹æŸ„ */}
      <div
        className={`
          ${direction === "horizontal" ? "w-1 h-8" : "h-1 w-8"}
          rounded-full
          bg-zinc-600
          group-hover:bg-emerald-400
          group-active:bg-emerald-300
          transition-colors
        `}
      />
    </div>
  );
}
```

---

### 1.6 ä¸‹æ‹‰åˆ·æ–°

```tsx
// components/ui/PullToRefresh.tsx
"use client";

import { useState, useRef, useCallback, ReactNode } from "react";
import { motion, useMotionValue, useTransform } from "framer-motion";

interface PullToRefreshProps {
  children: ReactNode;
  onRefresh: () => Promise<void>;
  threshold?: number;
}

export function PullToRefresh({
  children,
  onRefresh,
  threshold = 80,
}: PullToRefreshProps) {
  const [isRefreshing, setIsRefreshing] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const pullDistance = useMotionValue(0);
  const touchStartY = useRef(0);
  const isPulling = useRef(false);

  // åŠ¨ç”»å˜æ¢
  const rotate = useTransform(pullDistance, [0, threshold], [0, 180]);
  const scale = useTransform(pullDistance, [0, threshold], [0.8, 1]);
  const opacity = useTransform(pullDistance, [0, threshold / 2, threshold], [0, 0.5, 1]);

  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    if (containerRef.current?.scrollTop === 0) {
      touchStartY.current = e.touches[0].clientY;
      isPulling.current = true;
    }
  }, []);

  const handleTouchMove = useCallback((e: React.TouchEvent) => {
    if (!isPulling.current || isRefreshing) return;

    const deltaY = e.touches[0].clientY - touchStartY.current;
    if (deltaY > 0) {
      // ä½¿ç”¨é˜»å°¼æ•ˆæœ
      const dampedDelta = Math.min(deltaY * 0.5, threshold * 1.5);
      pullDistance.set(dampedDelta);
    }
  }, [isRefreshing, pullDistance, threshold]);

  const handleTouchEnd = useCallback(async () => {
    if (!isPulling.current) return;
    isPulling.current = false;

    if (pullDistance.get() >= threshold && !isRefreshing) {
      setIsRefreshing(true);
      pullDistance.set(threshold);

      try {
        await onRefresh();
      } finally {
        setIsRefreshing(false);
        pullDistance.set(0);
      }
    } else {
      pullDistance.set(0);
    }
  }, [pullDistance, threshold, isRefreshing, onRefresh]);

  return (
    <div className="relative overflow-hidden">
      {/* åˆ·æ–°æŒ‡ç¤ºå™¨ */}
      <motion.div
        className="absolute top-0 left-1/2 -translate-x-1/2 z-10 flex items-center justify-center"
        style={{
          y: useTransform(pullDistance, [0, threshold], [-40, 20]),
          opacity,
        }}
      >
        <motion.div
          className="w-8 h-8 rounded-full bg-zinc-800 flex items-center justify-center"
          style={{ scale, rotate: isRefreshing ? undefined : rotate }}
          animate={isRefreshing ? { rotate: 360 } : {}}
          transition={isRefreshing ? { repeat: Infinity, duration: 1, ease: "linear" } : {}}
        >
          <svg className="w-5 h-5 text-emerald-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 14l-7 7m0 0l-7-7m7 7V3" />
          </svg>
        </motion.div>
      </motion.div>

      {/* å†…å®¹å®¹å™¨ */}
      <motion.div
        ref={containerRef}
        className="overflow-auto"
        style={{ y: pullDistance }}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
      >
        {children}
      </motion.div>
    </div>
  );
}

// ä½¿ç”¨ç¤ºä¾‹
<PullToRefresh onRefresh={async () => {
  await fetchProblems();
}}>
  <ProblemList problems={problems} />
</PullToRefresh>
```

---

### 1.7 åŒæŒ‡ç¼©æ”¾ï¼ˆçŸ¥è¯†å›¾è°±ï¼‰

```tsx
// hooks/usePinchZoom.ts
"use client";

import { useRef, useCallback, useState } from "react";

interface PinchZoomState {
  scale: number;
  translateX: number;
  translateY: number;
}

export function usePinchZoom(
  minScale = 0.5,
  maxScale = 3
) {
  const [state, setState] = useState<PinchZoomState>({
    scale: 1,
    translateX: 0,
    translateY: 0,
  });

  const initialDistance = useRef(0);
  const initialScale = useRef(1);
  const initialCenter = useRef({ x: 0, y: 0 });

  const getDistance = (touches: TouchList) => {
    const [t1, t2] = [touches[0], touches[1]];
    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
  };

  const getCenter = (touches: TouchList) => {
    const [t1, t2] = [touches[0], touches[1]];
    return {
      x: (t1.clientX + t2.clientX) / 2,
      y: (t1.clientY + t2.clientY) / 2,
    };
  };

  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    if (e.touches.length === 2) {
      initialDistance.current = getDistance(e.touches);
      initialScale.current = state.scale;
      initialCenter.current = getCenter(e.touches);
    }
  }, [state.scale]);

  const handleTouchMove = useCallback((e: React.TouchEvent) => {
    if (e.touches.length === 2) {
      e.preventDefault();

      const currentDistance = getDistance(e.touches);
      const currentCenter = getCenter(e.touches);

      // è®¡ç®—ç¼©æ”¾
      const scaleChange = currentDistance / initialDistance.current;
      const newScale = Math.min(
        Math.max(initialScale.current * scaleChange, minScale),
        maxScale
      );

      // è®¡ç®—å¹³ç§»ï¼ˆä¿æŒç¼©æ”¾ä¸­å¿ƒï¼‰
      const deltaX = currentCenter.x - initialCenter.current.x;
      const deltaY = currentCenter.y - initialCenter.current.y;

      setState(prev => ({
        scale: newScale,
        translateX: prev.translateX + deltaX * 0.5,
        translateY: prev.translateY + deltaY * 0.5,
      }));

      initialCenter.current = currentCenter;
    }
  }, [minScale, maxScale]);

  const resetZoom = useCallback(() => {
    setState({ scale: 1, translateX: 0, translateY: 0 });
  }, []);

  return {
    ...state,
    handlers: {
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
    },
    resetZoom,
    setScale: (scale: number) => setState(prev => ({ ...prev, scale })),
  };
}

// ä½¿ç”¨ç¤ºä¾‹ - çŸ¥è¯†å›¾è°±
function KnowledgeGraph() {
  const { scale, translateX, translateY, handlers, resetZoom } = usePinchZoom();

  return (
    <div className="relative overflow-hidden" {...handlers}>
      <div
        style={{
          transform: `translate(${translateX}px, ${translateY}px) scale(${scale})`,
          transformOrigin: "center center",
        }}
      >
        <svg>{/* å›¾è°±å†…å®¹ */}</svg>
      </div>

      {/* ç¼©æ”¾æ§åˆ¶ */}
      <div className="absolute bottom-4 right-4 flex gap-2">
        <button onClick={() => setScale(scale * 1.2)}>+</button>
        <button onClick={resetZoom}>é‡ç½®</button>
        <button onClick={() => setScale(scale * 0.8)}>-</button>
      </div>
    </div>
  );
}
```

---

## äºŒã€iPad é€‚é… + iOS ç‰¹æ€§

### 2.1 å®‰å…¨åŒºåŸŸå®Œæ•´é€‚é…

```css
/* globals.css */

:root {
  /* å®‰å…¨åŒºåŸŸå˜é‡ */
  --safe-area-top: env(safe-area-inset-top, 0px);
  --safe-area-right: env(safe-area-inset-right, 0px);
  --safe-area-bottom: env(safe-area-inset-bottom, 0px);
  --safe-area-left: env(safe-area-inset-left, 0px);

  /* å¯¼èˆªæ é«˜åº¦ï¼ˆåŒ…å«å®‰å…¨åŒºåŸŸï¼‰ */
  --header-height: calc(56px + var(--safe-area-top));
  --bottom-nav-height: calc(64px + var(--safe-area-bottom));
}

/* å›ºå®šå¤´éƒ¨ */
.fixed-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding-top: var(--safe-area-top);
  z-index: 50;
}

/* å›ºå®šåº•éƒ¨å¯¼èˆª */
.fixed-bottom-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding-bottom: var(--safe-area-bottom);
  padding-left: var(--safe-area-left);
  padding-right: var(--safe-area-right);
  z-index: 50;
}

/* ä¸»å†…å®¹åŒºåŸŸ */
.main-content {
  padding-top: var(--header-height);
  padding-bottom: var(--bottom-nav-height);
  min-height: 100dvh;
}

/* å…¨å±æ¨¡æ€æ¡† */
.fullscreen-modal {
  position: fixed;
  inset: 0;
  padding-top: var(--safe-area-top);
  padding-bottom: var(--safe-area-bottom);
  padding-left: var(--safe-area-left);
  padding-right: var(--safe-area-right);
}

/* æ¨ªå±é€‚é… */
@media (orientation: landscape) {
  .landscape-safe {
    padding-left: max(16px, var(--safe-area-left));
    padding-right: max(16px, var(--safe-area-right));
  }
}
```

---

### 2.2 iPad åˆ†å±æ¨¡å¼é€‚é…

```tsx
// hooks/useViewportSize.ts
"use client";

import { useState, useEffect } from "react";

interface ViewportSize {
  width: number;
  height: number;
  isCompact: boolean;      // < 400px (Split View 1/3)
  isRegular: boolean;      // 400-700px (Split View 1/2)
  isFull: boolean;         // > 700px (Full screen)
  isLandscape: boolean;
  isSplitView: boolean;    // iPad åˆ†å±æ¨¡å¼æ£€æµ‹
}

export function useViewportSize(): ViewportSize {
  const [size, setSize] = useState<ViewportSize>({
    width: typeof window !== "undefined" ? window.innerWidth : 1024,
    height: typeof window !== "undefined" ? window.innerHeight : 768,
    isCompact: false,
    isRegular: false,
    isFull: true,
    isLandscape: true,
    isSplitView: false,
  });

  useEffect(() => {
    const updateSize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      const screenWidth = window.screen.width;

      // iPad Split View æ£€æµ‹
      const isSplitView = /iPad/.test(navigator.userAgent) && width < screenWidth * 0.9;

      setSize({
        width,
        height,
        isCompact: width < 400,
        isRegular: width >= 400 && width < 700,
        isFull: width >= 700,
        isLandscape: width > height,
        isSplitView,
      });
    };

    updateSize();
    window.addEventListener("resize", updateSize);
    return () => window.removeEventListener("resize", updateSize);
  }, []);

  return size;
}

// ä½¿ç”¨ç¤ºä¾‹
function AdaptiveLayout({ children }) {
  const { isCompact, isRegular, isSplitView } = useViewportSize();

  if (isCompact) {
    // æçª„è§†å›¾ï¼šå•åˆ—å †å 
    return <div className="flex flex-col">{children}</div>;
  }

  if (isRegular || isSplitView) {
    // ä¸­ç­‰å®½åº¦ï¼šç®€åŒ–å¸ƒå±€
    return <div className="flex flex-col lg:flex-row">{children}</div>;
  }

  // å…¨å®½ï¼šå®Œæ•´å¸ƒå±€
  return <div className="grid grid-cols-3 gap-4">{children}</div>;
}
```

---

### 2.3 é”®ç›˜å¿«æ·é”®ç³»ç»Ÿ

```tsx
// hooks/useKeyboardShortcuts.ts
"use client";

import { useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";

interface Shortcut {
  key: string;
  ctrl?: boolean;
  meta?: boolean;  // Cmd on Mac
  shift?: boolean;
  alt?: boolean;
  action: () => void;
  description: string;
}

const isMac = typeof navigator !== "undefined" && /Mac/.test(navigator.platform);

export function useKeyboardShortcuts(shortcuts: Shortcut[]) {
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    // å¿½ç•¥è¾“å…¥æ¡†ä¸­çš„å¿«æ·é”®
    if (
      e.target instanceof HTMLInputElement ||
      e.target instanceof HTMLTextAreaElement ||
      (e.target as HTMLElement).isContentEditable
    ) {
      return;
    }

    for (const shortcut of shortcuts) {
      const modifierMatch =
        (shortcut.ctrl ? e.ctrlKey : !e.ctrlKey || isMac) &&
        (shortcut.meta ? e.metaKey : !e.metaKey || !isMac) &&
        (shortcut.shift ? e.shiftKey : !e.shiftKey) &&
        (shortcut.alt ? e.altKey : !e.altKey);

      // Mac ä¸Š Cmd ç­‰åŒäº Ctrl
      const ctrlOrCmd = shortcut.ctrl && (isMac ? e.metaKey : e.ctrlKey);
      const keyMatch = e.key.toLowerCase() === shortcut.key.toLowerCase();

      if (keyMatch && (modifierMatch || ctrlOrCmd)) {
        e.preventDefault();
        shortcut.action();
        return;
      }
    }
  }, [shortcuts]);

  useEffect(() => {
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [handleKeyDown]);
}

// å…¨å±€å¿«æ·é”®é…ç½®
export function useGlobalShortcuts() {
  const router = useRouter();

  useKeyboardShortcuts([
    // å¯¼èˆª
    { key: "k", ctrl: true, action: () => openSearchModal(), description: "æ‰“å¼€æœç´¢" },
    { key: "h", action: () => router.push("/"), description: "è¿”å›é¦–é¡µ" },
    { key: "p", action: () => router.push("/problems"), description: "é¢˜åº“" },
    { key: "Escape", action: () => closeModal(), description: "å…³é—­å¼¹çª—" },

    // é¢˜ç›®æ“ä½œ
    { key: "Enter", ctrl: true, action: () => submitCode(), description: "æäº¤ä»£ç " },
    { key: "r", ctrl: true, action: () => runTests(), description: "è¿è¡Œæµ‹è¯•" },
    { key: "[", action: () => goToPrevProblem(), description: "ä¸Šä¸€é¢˜" },
    { key: "]", action: () => goToNextProblem(), description: "ä¸‹ä¸€é¢˜" },

    // ç¼–è¾‘å™¨
    { key: "s", ctrl: true, action: () => saveCode(), description: "ä¿å­˜ä»£ç " },
    { key: "/", ctrl: true, action: () => toggleComment(), description: "åˆ‡æ¢æ³¨é‡Š" },
    { key: "f", ctrl: true, action: () => formatCode(), description: "æ ¼å¼åŒ–ä»£ç " },
  ]);
}

// å¿«æ·é”®å¸®åŠ©é¢æ¿
export function ShortcutHelp({ shortcuts }: { shortcuts: Shortcut[] }) {
  return (
    <div className="grid grid-cols-2 gap-4 p-4">
      {shortcuts.map((s, i) => (
        <div key={i} className="flex items-center justify-between">
          <span className="text-zinc-400">{s.description}</span>
          <kbd className="px-2 py-1 rounded bg-zinc-800 text-xs font-mono">
            {s.ctrl && (isMac ? "âŒ˜" : "Ctrl+")}
            {s.shift && "â‡§"}
            {s.alt && (isMac ? "âŒ¥" : "Alt+")}
            {s.key.toUpperCase()}
          </kbd>
        </div>
      ))}
    </div>
  );
}
```

---

### 2.4 Haptic è§¦è§‰åé¦ˆ

```tsx
// lib/haptics.ts

type HapticStyle = "light" | "medium" | "heavy" | "success" | "warning" | "error" | "selection";

interface HapticOptions {
  style?: HapticStyle;
  pattern?: number[]; // æŒ¯åŠ¨æ¨¡å¼ [æŒ¯åŠ¨, æš‚åœ, æŒ¯åŠ¨, ...]
}

class HapticEngine {
  private isSupported: boolean;

  constructor() {
    this.isSupported = typeof navigator !== "undefined" && "vibrate" in navigator;
  }

  // åŸºç¡€æŒ¯åŠ¨
  vibrate(pattern: number | number[]) {
    if (this.isSupported) {
      navigator.vibrate(pattern);
    }
  }

  // é¢„è®¾è§¦è§‰åé¦ˆ
  feedback(style: HapticStyle = "light") {
    const patterns: Record<HapticStyle, number[]> = {
      light: [10],
      medium: [20],
      heavy: [30],
      success: [10, 50, 10],
      warning: [20, 30, 20],
      error: [30, 50, 30, 50, 30],
      selection: [5],
    };

    this.vibrate(patterns[style]);
  }

  // æŒ‰é’®ç‚¹å‡»
  buttonTap() {
    this.feedback("light");
  }

  // æ“ä½œæˆåŠŸ
  success() {
    this.feedback("success");
  }

  // é”™è¯¯æç¤º
  error() {
    this.feedback("error");
  }

  // åˆ‡æ¢é€‰æ‹©
  selection() {
    this.feedback("selection");
  }
}

export const haptics = new HapticEngine();

// ä½¿ç”¨ç¤ºä¾‹
<button
  onClick={() => {
    haptics.buttonTap();
    handleClick();
  }}
>
  æäº¤
</button>

// æˆåŠŸæ—¶
async function submitCode() {
  const result = await api.submit(code);
  if (result.success) {
    haptics.success();
    showSuccessAnimation();
  } else {
    haptics.error();
    showErrorMessage();
  }
}
```

---

### 2.5 æ·±è‰²æ¨¡å¼ä¸ç³»ç»Ÿè®¾ç½®

```tsx
// hooks/useSystemPreferences.ts
"use client";

import { useState, useEffect } from "react";

interface SystemPreferences {
  colorScheme: "light" | "dark";
  reducedMotion: boolean;
  reducedTransparency: boolean;
  highContrast: boolean;
  fontSize: "default" | "large" | "xlarge";
}

export function useSystemPreferences(): SystemPreferences {
  const [prefs, setPrefs] = useState<SystemPreferences>({
    colorScheme: "dark",
    reducedMotion: false,
    reducedTransparency: false,
    highContrast: false,
    fontSize: "default",
  });

  useEffect(() => {
    // é¢œè‰²æ¨¡å¼
    const darkQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const motionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
    const transparencyQuery = window.matchMedia("(prefers-reduced-transparency: reduce)");
    const contrastQuery = window.matchMedia("(prefers-contrast: more)");

    const updatePrefs = () => {
      setPrefs({
        colorScheme: darkQuery.matches ? "dark" : "light",
        reducedMotion: motionQuery.matches,
        reducedTransparency: transparencyQuery.matches,
        highContrast: contrastQuery.matches,
        fontSize: "default", // éœ€è¦ä» localStorage æˆ–å…¶ä»–æ¥æºè·å–
      });
    };

    updatePrefs();

    darkQuery.addEventListener("change", updatePrefs);
    motionQuery.addEventListener("change", updatePrefs);

    return () => {
      darkQuery.removeEventListener("change", updatePrefs);
      motionQuery.removeEventListener("change", updatePrefs);
    };
  }, []);

  return prefs;
}

// åŠ¨ç”»ç»„ä»¶åŒ…è£…å™¨
export function AnimatedComponent({
  children,
  animation,
  reducedMotionFallback
}: {
  children: React.ReactNode;
  animation: object;
  reducedMotionFallback?: object;
}) {
  const { reducedMotion } = useSystemPreferences();

  return (
    <motion.div
      {...(reducedMotion ? reducedMotionFallback || {} : animation)}
    >
      {children}
    </motion.div>
  );
}
```

---

### 2.6 æ‹–æ”¾æ”¯æŒï¼ˆè·¨åº”ç”¨ï¼‰

```tsx
// components/ui/DragDropZone.tsx
"use client";

import { useState, useCallback } from "react";

interface DragDropZoneProps {
  onDrop: (data: string, type: string) => void;
  accept?: string[]; // æ¥å—çš„ MIME ç±»å‹
  children: React.ReactNode;
}

export function DragDropZone({
  onDrop,
  accept = ["text/plain", "text/javascript", "application/json"],
  children,
}: DragDropZoneProps) {
  const [isDragOver, setIsDragOver] = useState(false);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();

    // æ£€æŸ¥æ˜¯å¦æ¥å—è¯¥ç±»å‹
    const hasValidType = accept.some(type =>
      e.dataTransfer.types.includes(type) ||
      e.dataTransfer.types.includes("Files")
    );

    if (hasValidType) {
      setIsDragOver(true);
      e.dataTransfer.dropEffect = "copy";
    }
  }, [accept]);

  const handleDragLeave = useCallback(() => {
    setIsDragOver(false);
  }, []);

  const handleDrop = useCallback(async (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);

    // å¤„ç†æ–‡ä»¶
    if (e.dataTransfer.files.length > 0) {
      const file = e.dataTransfer.files[0];
      const text = await file.text();
      onDrop(text, file.type);
      return;
    }

    // å¤„ç†æ–‡æœ¬
    const text = e.dataTransfer.getData("text/plain");
    if (text) {
      onDrop(text, "text/plain");
    }
  }, [onDrop]);

  return (
    <div
      className={`
        relative transition-all duration-200
        ${isDragOver ? "ring-2 ring-emerald-500 ring-offset-2 ring-offset-zinc-900" : ""}
      `}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {children}

      {/* æ‹–æ”¾è¦†ç›–å±‚ */}
      {isDragOver && (
        <div className="absolute inset-0 bg-emerald-500/10 backdrop-blur-sm flex items-center justify-center rounded-xl border-2 border-dashed border-emerald-500">
          <div className="text-center">
            <div className="text-4xl mb-2">ğŸ“¥</div>
            <p className="text-emerald-400 font-medium">é‡Šæ”¾ä»¥å¯¼å…¥ä»£ç </p>
          </div>
        </div>
      )}
    </div>
  );
}

// ä½¿ç”¨ç¤ºä¾‹
<DragDropZone onDrop={(code, type) => {
  setEditorContent(code);
  toast.success("ä»£ç å·²å¯¼å…¥");
}}>
  <CodeEditor value={code} onChange={setCode} />
</DragDropZone>
```

---

## ä¸‰ã€åŠ¨ç”»æ•ˆæœ + å¾®äº¤äº’

### 3.1 é¡µé¢è½¬åœºåŠ¨ç”»

```tsx
// components/PageTransition.tsx
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { usePathname } from "next/navigation";

const pageVariants = {
  initial: {
    opacity: 0,
    y: 20,
    scale: 0.98,
  },
  enter: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: {
      duration: 0.3,
      ease: [0.25, 0.1, 0.25, 1],
    },
  },
  exit: {
    opacity: 0,
    y: -10,
    scale: 0.98,
    transition: {
      duration: 0.2,
      ease: [0.25, 0.1, 0.25, 1],
    },
  },
};

// Shared Element è¿‡æ¸¡
const sharedElementVariants = {
  initial: { opacity: 0, scale: 0.8 },
  animate: {
    opacity: 1,
    scale: 1,
    transition: {
      type: "spring",
      stiffness: 300,
      damping: 30,
    }
  },
  exit: { opacity: 0, scale: 0.8 },
};

export function PageTransition({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();

  return (
    <AnimatePresence mode="wait" initial={false}>
      <motion.div
        key={pathname}
        variants={pageVariants}
        initial="initial"
        animate="enter"
        exit="exit"
      >
        {children}
      </motion.div>
    </AnimatePresence>
  );
}

// åˆ—è¡¨é¡¹äº¤é”™åŠ¨ç”»
export function StaggerList({
  children,
  staggerDelay = 0.05,
}: {
  children: React.ReactNode[];
  staggerDelay?: number;
}) {
  return (
    <motion.div
      initial="hidden"
      animate="visible"
      variants={{
        visible: {
          transition: {
            staggerChildren: staggerDelay,
          },
        },
      }}
    >
      {children.map((child, i) => (
        <motion.div
          key={i}
          variants={{
            hidden: { opacity: 0, y: 20 },
            visible: {
              opacity: 1,
              y: 0,
              transition: {
                type: "spring",
                stiffness: 300,
                damping: 24,
              }
            },
          }}
        >
          {child}
        </motion.div>
      ))}
    </motion.div>
  );
}
```

---

### 3.2 éª¨æ¶å±ç»„ä»¶

```tsx
// components/ui/Skeleton.tsx
"use client";

import { motion } from "framer-motion";

interface SkeletonProps {
  className?: string;
  variant?: "text" | "circular" | "rectangular" | "rounded";
  width?: string | number;
  height?: string | number;
  animation?: "pulse" | "wave" | "none";
}

export function Skeleton({
  className,
  variant = "rectangular",
  width,
  height,
  animation = "pulse",
}: SkeletonProps) {
  const variantClasses = {
    text: "rounded h-4",
    circular: "rounded-full",
    rectangular: "",
    rounded: "rounded-xl",
  };

  const animationClasses = {
    pulse: "animate-pulse",
    wave: "skeleton-wave",
    none: "",
  };

  return (
    <div
      className={`
        bg-zinc-800
        ${variantClasses[variant]}
        ${animationClasses[animation]}
        ${className}
      `}
      style={{ width, height }}
    />
  );
}

// é¢„è®¾éª¨æ¶å±å¸ƒå±€
export function ProblemCardSkeleton() {
  return (
    <div className="rounded-xl bg-zinc-900 border border-zinc-800 p-4">
      <div className="flex items-center gap-3 mb-3">
        <Skeleton variant="circular" width={40} height={40} />
        <div className="flex-1">
          <Skeleton variant="text" width="60%" className="mb-2" />
          <Skeleton variant="text" width="40%" height={12} />
        </div>
      </div>
      <Skeleton variant="text" className="mb-2" />
      <Skeleton variant="text" width="80%" />
    </div>
  );
}

export function ProblemListSkeleton({ count = 5 }: { count?: number }) {
  return (
    <div className="space-y-4">
      {Array.from({ length: count }).map((_, i) => (
        <ProblemCardSkeleton key={i} />
      ))}
    </div>
  );
}

// ä»£ç ç¼–è¾‘å™¨éª¨æ¶å±
export function EditorSkeleton() {
  return (
    <div className="h-full bg-zinc-900 p-4">
      <div className="flex gap-2 mb-4">
        <Skeleton variant="rounded" width={80} height={32} />
        <Skeleton variant="rounded" width={80} height={32} />
        <Skeleton variant="rounded" width={80} height={32} />
      </div>
      <div className="space-y-2">
        {Array.from({ length: 15 }).map((_, i) => (
          <Skeleton
            key={i}
            variant="text"
            width={`${Math.random() * 40 + 40}%`}
            height={16}
          />
        ))}
      </div>
    </div>
  );
}
```

**Wave åŠ¨ç”» CSS:**

```css
/* globals.css */
.skeleton-wave {
  position: relative;
  overflow: hidden;
}

.skeleton-wave::after {
  content: "";
  position: absolute;
  inset: 0;
  transform: translateX(-100%);
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.08),
    transparent
  );
  animation: skeleton-wave 1.5s infinite;
}

@keyframes skeleton-wave {
  100% {
    transform: translateX(100%);
  }
}
```

---

### 3.3 æˆåŠŸåº†ç¥åŠ¨ç”»

```tsx
// components/ui/Confetti.tsx
"use client";

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";

interface ConfettiPiece {
  id: number;
  x: number;
  color: string;
  delay: number;
  rotation: number;
}

const colors = [
  "#10B981", // emerald-500
  "#3B82F6", // blue-500
  "#8B5CF6", // violet-500
  "#F59E0B", // amber-500
  "#EF4444", // red-500
  "#EC4899", // pink-500
];

export function Confetti({
  active,
  duration = 3000,
  particleCount = 50,
}: {
  active: boolean;
  duration?: number;
  particleCount?: number;
}) {
  const [pieces, setPieces] = useState<ConfettiPiece[]>([]);

  useEffect(() => {
    if (active) {
      const newPieces: ConfettiPiece[] = Array.from({ length: particleCount }).map((_, i) => ({
        id: i,
        x: Math.random() * 100,
        color: colors[Math.floor(Math.random() * colors.length)],
        delay: Math.random() * 0.5,
        rotation: Math.random() * 360,
      }));
      setPieces(newPieces);

      const timer = setTimeout(() => setPieces([]), duration);
      return () => clearTimeout(timer);
    }
  }, [active, duration, particleCount]);

  return (
    <AnimatePresence>
      {pieces.length > 0 && (
        <div className="fixed inset-0 pointer-events-none z-50 overflow-hidden">
          {pieces.map((piece) => (
            <motion.div
              key={piece.id}
              className="absolute w-3 h-3"
              style={{
                left: `${piece.x}%`,
                backgroundColor: piece.color,
                borderRadius: Math.random() > 0.5 ? "50%" : "2px",
              }}
              initial={{
                y: -20,
                opacity: 1,
                rotate: piece.rotation,
                scale: Math.random() * 0.5 + 0.5,
              }}
              animate={{
                y: window.innerHeight + 100,
                opacity: [1, 1, 0],
                rotate: piece.rotation + (Math.random() > 0.5 ? 360 : -360),
              }}
              transition={{
                duration: 2.5 + Math.random(),
                delay: piece.delay,
                ease: [0.25, 0.1, 0.25, 1],
              }}
            />
          ))}
        </div>
      )}
    </AnimatePresence>
  );
}

// æˆåŠŸå¼¹çª—ç»„ä»¶
export function SuccessModal({
  isOpen,
  onClose,
  title = "æ­å–œï¼",
  message = "ä½ æˆåŠŸè§£å†³äº†è¿™é“é¢˜ç›®ï¼",
}: {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  message?: string;
}) {
  return (
    <>
      <Confetti active={isOpen} />

      <AnimatePresence>
        {isOpen && (
          <motion.div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
          >
            <motion.div
              className="bg-zinc-900 rounded-2xl p-8 text-center max-w-sm mx-4 border border-zinc-800"
              initial={{ scale: 0.8, y: 20 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 20 }}
              transition={{ type: "spring", damping: 20 }}
              onClick={(e) => e.stopPropagation()}
            >
              {/* æˆåŠŸå›¾æ ‡åŠ¨ç”» */}
              <motion.div
                className="w-20 h-20 mx-auto mb-4 rounded-full bg-emerald-500/20 flex items-center justify-center"
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                transition={{ delay: 0.2, type: "spring", damping: 10 }}
              >
                <motion.svg
                  className="w-10 h-10 text-emerald-500"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth={3}
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <motion.path
                    d="M5 13l4 4L19 7"
                    initial={{ pathLength: 0 }}
                    animate={{ pathLength: 1 }}
                    transition={{ delay: 0.4, duration: 0.4 }}
                  />
                </motion.svg>
              </motion.div>

              <h2 className="text-2xl font-bold mb-2">{title}</h2>
              <p className="text-zinc-400 mb-6">{message}</p>

              <div className="flex gap-3 justify-center">
                <button
                  onClick={onClose}
                  className="px-6 py-2 rounded-lg bg-zinc-800 hover:bg-zinc-700 transition-colors"
                >
                  ç»§ç»­åˆ·é¢˜
                </button>
                <button
                  onClick={() => {/* ä¸‹ä¸€é¢˜ */}}
                  className="px-6 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 transition-colors"
                >
                  ä¸‹ä¸€é¢˜ â†’
                </button>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}
```

---

### 3.4 æ•°å­—æ»šåŠ¨åŠ¨ç”»

```tsx
// components/ui/AnimatedNumber.tsx
"use client";

import { useEffect, useRef, useState } from "react";
import { motion, useSpring, useTransform } from "framer-motion";

interface AnimatedNumberProps {
  value: number;
  duration?: number;
  className?: string;
  format?: (n: number) => string;
}

export function AnimatedNumber({
  value,
  duration = 1000,
  className,
  format = (n) => Math.round(n).toLocaleString(),
}: AnimatedNumberProps) {
  const spring = useSpring(0, {
    stiffness: 100,
    damping: 30,
    duration: duration / 1000,
  });

  const display = useTransform(spring, (latest) => format(latest));
  const [displayValue, setDisplayValue] = useState(format(0));

  useEffect(() => {
    spring.set(value);
  }, [spring, value]);

  useEffect(() => {
    return display.on("change", (v) => setDisplayValue(v));
  }, [display]);

  return (
    <motion.span className={className}>
      {displayValue}
    </motion.span>
  );
}

// è¿›åº¦ç¯åŠ¨ç”»
export function AnimatedProgress({
  value,
  max = 100,
  size = 120,
  strokeWidth = 8,
  className,
}: {
  value: number;
  max?: number;
  size?: number;
  strokeWidth?: number;
  className?: string;
}) {
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const progress = (value / max) * 100;

  return (
    <div className={`relative ${className}`} style={{ width: size, height: size }}>
      <svg className="transform -rotate-90" width={size} height={size}>
        {/* èƒŒæ™¯åœ† */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          fill="none"
          stroke="currentColor"
          strokeWidth={strokeWidth}
          className="text-zinc-800"
        />
        {/* è¿›åº¦åœ† */}
        <motion.circle
          cx={size / 2}
          cy={size / 2}
          r={radius}
          fill="none"
          stroke="currentColor"
          strokeWidth={strokeWidth}
          strokeLinecap="round"
          className="text-emerald-500"
          initial={{ strokeDasharray: circumference, strokeDashoffset: circumference }}
          animate={{ strokeDashoffset: circumference - (progress / 100) * circumference }}
          transition={{ duration: 1, ease: "easeOut" }}
        />
      </svg>

      {/* ä¸­å¿ƒæ•°å­— */}
      <div className="absolute inset-0 flex items-center justify-center">
        <AnimatedNumber
          value={progress}
          className="text-2xl font-bold"
          format={(n) => `${Math.round(n)}%`}
        />
      </div>
    </div>
  );
}

// ä½¿ç”¨ç¤ºä¾‹
<div className="flex items-center gap-8">
  <AnimatedProgress value={75} />
  <div>
    <div className="text-sm text-zinc-400">å·²å®Œæˆ</div>
    <AnimatedNumber value={150} className="text-3xl font-bold" />
    <span className="text-zinc-500">/ 200 é¢˜</span>
  </div>
</div>
```

---

### 3.5 å¾®äº¤äº’é›†åˆ

```tsx
// components/ui/MicroInteractions.tsx
"use client";

import { motion } from "framer-motion";

// 1. å¿ƒè·³æ•ˆæœï¼ˆæ”¶è—æŒ‰é’®ï¼‰
export function HeartButton({
  isLiked,
  onToggle
}: {
  isLiked: boolean;
  onToggle: () => void;
}) {
  return (
    <motion.button
      onClick={onToggle}
      whileTap={{ scale: 0.9 }}
      className="p-2 rounded-full hover:bg-zinc-800 transition-colors"
    >
      <motion.svg
        className={`w-6 h-6 ${isLiked ? "text-red-500" : "text-zinc-400"}`}
        viewBox="0 0 24 24"
        fill={isLiked ? "currentColor" : "none"}
        stroke="currentColor"
        strokeWidth={2}
        animate={isLiked ? {
          scale: [1, 1.3, 1],
          transition: { duration: 0.3 }
        } : {}}
      >
        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" />
      </motion.svg>
    </motion.button>
  );
}

// 2. åˆ‡æ¢å¼€å…³
export function Toggle({
  isOn,
  onToggle,
  size = "md",
}: {
  isOn: boolean;
  onToggle: () => void;
  size?: "sm" | "md" | "lg";
}) {
  const sizes = {
    sm: { width: 36, height: 20, circle: 16 },
    md: { width: 48, height: 26, circle: 22 },
    lg: { width: 60, height: 32, circle: 28 },
  };
  const s = sizes[size];

  return (
    <motion.button
      className={`relative rounded-full ${isOn ? "bg-emerald-500" : "bg-zinc-700"}`}
      style={{ width: s.width, height: s.height }}
      onClick={onToggle}
      whileTap={{ scale: 0.95 }}
    >
      <motion.div
        className="absolute top-1/2 -translate-y-1/2 rounded-full bg-white shadow-md"
        style={{ width: s.circle, height: s.circle }}
        initial={false}
        animate={{
          x: isOn ? s.width - s.circle - 2 : 2,
        }}
        transition={{ type: "spring", stiffness: 500, damping: 30 }}
      />
    </motion.button>
  );
}

// 3. åŠ è½½æŒ‰é’®
export function LoadingButton({
  isLoading,
  children,
  onClick,
  className,
}: {
  isLoading: boolean;
  children: React.ReactNode;
  onClick: () => void;
  className?: string;
}) {
  return (
    <motion.button
      className={`relative overflow-hidden ${className}`}
      onClick={onClick}
      disabled={isLoading}
      whileTap={{ scale: 0.98 }}
    >
      <motion.span
        animate={{ opacity: isLoading ? 0 : 1 }}
        transition={{ duration: 0.15 }}
      >
        {children}
      </motion.span>

      {isLoading && (
        <motion.div
          className="absolute inset-0 flex items-center justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          <motion.div
            className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full"
            animate={{ rotate: 360 }}
            transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
          />
        </motion.div>
      )}
    </motion.button>
  );
}

// 4. æŠ–åŠ¨æ•ˆæœï¼ˆé”™è¯¯æç¤ºï¼‰
export function ShakeOnError({
  hasError,
  children,
}: {
  hasError: boolean;
  children: React.ReactNode;
}) {
  return (
    <motion.div
      animate={hasError ? {
        x: [0, -10, 10, -10, 10, 0],
        transition: { duration: 0.5 }
      } : {}}
    >
      {children}
    </motion.div>
  );
}

// 5. å±•å¼€/æ”¶èµ·åŠ¨ç”»
export function Collapsible({
  isOpen,
  children,
}: {
  isOpen: boolean;
  children: React.ReactNode;
}) {
  return (
    <motion.div
      initial={false}
      animate={{
        height: isOpen ? "auto" : 0,
        opacity: isOpen ? 1 : 0,
      }}
      transition={{
        height: { duration: 0.3, ease: [0.25, 0.1, 0.25, 1] },
        opacity: { duration: 0.2 },
      }}
      style={{ overflow: "hidden" }}
    >
      {children}
    </motion.div>
  );
}

// 6. æ‚¬æµ®å¡ç‰‡å…‰æ•ˆ
export function GlowCard({
  children,
  className,
}: {
  children: React.ReactNode;
  className?: string;
}) {
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [isHovered, setIsHovered] = useState(false);

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    setMousePos({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
  };

  return (
    <motion.div
      className={`relative overflow-hidden ${className}`}
      onMouseMove={handleMouseMove}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      {/* å…‰æ•ˆ */}
      <motion.div
        className="pointer-events-none absolute -inset-px opacity-0 transition-opacity duration-300"
        style={{
          background: `radial-gradient(400px circle at ${mousePos.x}px ${mousePos.y}px, rgba(16, 185, 129, 0.15), transparent 40%)`,
        }}
        animate={{ opacity: isHovered ? 1 : 0 }}
      />

      {children}
    </motion.div>
  );
}
```

---

## å››ã€æ€§èƒ½ä¼˜åŒ– + å¯¼èˆªä½“éªŒ

### 4.1 è™šæ‹Ÿåˆ—è¡¨

```tsx
// components/ui/VirtualList.tsx
"use client";

import { useRef, useState, useEffect, useCallback, ReactNode } from "react";

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  renderItem: (item: T, index: number) => ReactNode;
  overscan?: number;
  className?: string;
}

export function VirtualList<T>({
  items,
  itemHeight,
  renderItem,
  overscan = 5,
  className,
}: VirtualListProps<T>) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(0);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => setScrollTop(container.scrollTop);
    const handleResize = () => setContainerHeight(container.clientHeight);

    handleResize();
    container.addEventListener("scroll", handleScroll, { passive: true });
    window.addEventListener("resize", handleResize);

    return () => {
      container.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  // è®¡ç®—å¯è§èŒƒå›´
  const totalHeight = items.length * itemHeight;
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
  const endIndex = Math.min(
    items.length - 1,
    Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
  );

  const visibleItems = items.slice(startIndex, endIndex + 1);

  return (
    <div
      ref={containerRef}
      className={`overflow-auto ${className}`}
    >
      <div style={{ height: totalHeight, position: "relative" }}>
        {visibleItems.map((item, i) => (
          <div
            key={startIndex + i}
            style={{
              position: "absolute",
              top: (startIndex + i) * itemHeight,
              left: 0,
              right: 0,
              height: itemHeight,
            }}
          >
            {renderItem(item, startIndex + i)}
          </div>
        ))}
      </div>
    </div>
  );
}

// ä½¿ç”¨ç¤ºä¾‹
<VirtualList
  items={problems}
  itemHeight={80}
  className="h-[calc(100vh-200px)]"
  renderItem={(problem, index) => (
    <ProblemCard problem={problem} />
  )}
/>
```

---

### 4.2 æ‡’åŠ è½½ç»„ä»¶

```tsx
// components/ui/LazyLoad.tsx
"use client";

import { useState, useEffect, useRef, ReactNode, Suspense } from "react";

interface LazyLoadProps {
  children: ReactNode;
  fallback?: ReactNode;
  rootMargin?: string;
  threshold?: number;
}

export function LazyLoad({
  children,
  fallback = <div className="animate-pulse bg-zinc-800 rounded-xl h-40" />,
  rootMargin = "200px",
  threshold = 0,
}: LazyLoadProps) {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.disconnect();
        }
      },
      { rootMargin, threshold }
    );

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => observer.disconnect();
  }, [rootMargin, threshold]);

  return (
    <div ref={ref}>
      {isVisible ? (
        <Suspense fallback={fallback}>
          {children}
        </Suspense>
      ) : (
        fallback
      )}
    </div>
  );
}

// æ‡’åŠ è½½å›¾ç‰‡
export function LazyImage({
  src,
  alt,
  className,
  placeholder,
}: {
  src: string;
  alt: string;
  className?: string;
  placeholder?: string;
}) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: "200px" }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div ref={imgRef} className={`relative overflow-hidden ${className}`}>
      {/* å ä½ç¬¦ */}
      {!isLoaded && (
        <div className="absolute inset-0 bg-zinc-800 animate-pulse" />
      )}

      {/* å®é™…å›¾ç‰‡ */}
      {isInView && (
        <img
          src={src}
          alt={alt}
          className={`w-full h-full object-cover transition-opacity duration-300 ${
            isLoaded ? "opacity-100" : "opacity-0"
          }`}
          onLoad={() => setIsLoaded(true)}
        />
      )}
    </div>
  );
}
```

---

### 4.3 å…¨å±€æœç´¢ (Cmd+K)

```tsx
// components/SearchModal.tsx
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useRouter } from "next/navigation";

interface SearchResult {
  id: string;
  title: string;
  type: "problem" | "concept" | "hook" | "component";
  path: string;
  description?: string;
  icon?: string;
}

export function SearchModal() {
  const [isOpen, setIsOpen] = useState(false);
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult[]>([]);
  const [selectedIndex, setSelectedIndex] = useState(0);
  const inputRef = useRef<HTMLInputElement>(null);
  const router = useRouter();

  // Cmd+K å¿«æ·é”®
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault();
        setIsOpen(true);
      }

      if (e.key === "Escape") {
        setIsOpen(false);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  // è‡ªåŠ¨èšç„¦
  useEffect(() => {
    if (isOpen) {
      setTimeout(() => inputRef.current?.focus(), 100);
    } else {
      setQuery("");
      setResults([]);
      setSelectedIndex(0);
    }
  }, [isOpen]);

  // æœç´¢é€»è¾‘
  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }

    // æ¨¡æ‹Ÿæœç´¢ - å®é™…åº”ç”¨ä¸­æ›¿æ¢ä¸ºçœŸå®æœç´¢
    const mockSearch = async () => {
      // è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æœç´¢ API æˆ–æœ¬åœ°æœç´¢
      const allItems: SearchResult[] = [
        { id: "1", title: "ä¸¤æ•°ä¹‹å’Œ", type: "problem", path: "/problems/two-sum", icon: "ğŸ“" },
        { id: "2", title: "useState", type: "hook", path: "/use-state", icon: "ğŸª" },
        { id: "3", title: "äºŒå‰æ ‘", type: "concept", path: "/binary-tree", icon: "ğŸŒ³" },
        // ... æ›´å¤šæ•°æ®
      ];

      const filtered = allItems.filter(item =>
        item.title.toLowerCase().includes(query.toLowerCase())
      );

      setResults(filtered.slice(0, 8));
      setSelectedIndex(0);
    };

    const debounce = setTimeout(mockSearch, 150);
    return () => clearTimeout(debounce);
  }, [query]);

  // é”®ç›˜å¯¼èˆª
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        setSelectedIndex(i => Math.min(i + 1, results.length - 1));
        break;
      case "ArrowUp":
        e.preventDefault();
        setSelectedIndex(i => Math.max(i - 1, 0));
        break;
      case "Enter":
        if (results[selectedIndex]) {
          router.push(results[selectedIndex].path);
          setIsOpen(false);
        }
        break;
    }
  }, [results, selectedIndex, router]);

  const typeLabels = {
    problem: "é¢˜ç›®",
    concept: "æ¦‚å¿µ",
    hook: "Hook",
    component: "ç»„ä»¶",
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className="fixed inset-0 z-50 flex items-start justify-center pt-[20vh] bg-black/50 backdrop-blur-sm"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          onClick={() => setIsOpen(false)}
        >
          <motion.div
            className="w-full max-w-xl mx-4 bg-zinc-900 rounded-2xl border border-zinc-800 shadow-2xl overflow-hidden"
            initial={{ scale: 0.95, y: -20 }}
            animate={{ scale: 1, y: 0 }}
            exit={{ scale: 0.95, y: -20 }}
            onClick={(e) => e.stopPropagation()}
          >
            {/* æœç´¢è¾“å…¥ */}
            <div className="flex items-center gap-3 p-4 border-b border-zinc-800">
              <svg className="w-5 h-5 text-zinc-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
              <input
                ref={inputRef}
                type="text"
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder="æœç´¢é¢˜ç›®ã€æ¦‚å¿µã€Hook..."
                className="flex-1 bg-transparent outline-none text-lg placeholder:text-zinc-600"
              />
              <kbd className="hidden sm:block px-2 py-1 text-xs bg-zinc-800 rounded text-zinc-500">
                ESC
              </kbd>
            </div>

            {/* æœç´¢ç»“æœ */}
            {results.length > 0 && (
              <div className="max-h-80 overflow-auto p-2">
                {results.map((result, index) => (
                  <button
                    key={result.id}
                    className={`w-full flex items-center gap-3 p-3 rounded-lg text-left transition-colors ${
                      index === selectedIndex
                        ? "bg-emerald-500/20 text-emerald-400"
                        : "hover:bg-zinc-800"
                    }`}
                    onClick={() => {
                      router.push(result.path);
                      setIsOpen(false);
                    }}
                    onMouseEnter={() => setSelectedIndex(index)}
                  >
                    <span className="text-xl">{result.icon}</span>
                    <div className="flex-1 min-w-0">
                      <div className="font-medium truncate">{result.title}</div>
                      {result.description && (
                        <div className="text-sm text-zinc-500 truncate">
                          {result.description}
                        </div>
                      )}
                    </div>
                    <span className="text-xs text-zinc-600 px-2 py-1 bg-zinc-800 rounded">
                      {typeLabels[result.type]}
                    </span>
                  </button>
                ))}
              </div>
            )}

            {/* ç©ºçŠ¶æ€ */}
            {query && results.length === 0 && (
              <div className="p-8 text-center text-zinc-500">
                <div className="text-4xl mb-2">ğŸ”</div>
                <p>æœªæ‰¾åˆ° "{query}" ç›¸å…³å†…å®¹</p>
              </div>
            )}

            {/* å¿«æ·é”®æç¤º */}
            <div className="flex items-center justify-between px-4 py-3 border-t border-zinc-800 text-xs text-zinc-600">
              <div className="flex items-center gap-4">
                <span><kbd className="px-1.5 py-0.5 bg-zinc-800 rounded">â†‘â†“</kbd> å¯¼èˆª</span>
                <span><kbd className="px-1.5 py-0.5 bg-zinc-800 rounded">â†µ</kbd> é€‰æ‹©</span>
              </div>
              <span><kbd className="px-1.5 py-0.5 bg-zinc-800 rounded">âŒ˜K</kbd> æ‰“å¼€æœç´¢</span>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

---

### 4.4 é¢„åŠ è½½ä¸ç¼“å­˜

```tsx
// lib/prefetch.ts
import { cache } from "react";

// React cache ç”¨äºè¯·æ±‚å»é‡
export const getProblem = cache(async (id: string) => {
  const res = await fetch(`/api/problems/${id}`);
  return res.json();
});

// é¢„åŠ è½½é’©å­
export function usePrefetch() {
  const prefetchProblem = useCallback((id: string) => {
    // ä½¿ç”¨ router.prefetch é¢„åŠ è½½è·¯ç”±
    router.prefetch(`/problems/${id}`);

    // é¢„åŠ è½½æ•°æ®
    getProblem(id);
  }, []);

  return { prefetchProblem };
}

// åœ¨åˆ—è¡¨ä¸­ä½¿ç”¨
function ProblemList({ problems }) {
  const { prefetchProblem } = usePrefetch();

  return (
    <div>
      {problems.map(problem => (
        <Link
          key={problem.id}
          href={`/problems/${problem.id}`}
          onMouseEnter={() => prefetchProblem(problem.id)}
          onTouchStart={() => prefetchProblem(problem.id)}
        >
          {problem.title}
        </Link>
      ))}
    </div>
  );
}
```

---

### 4.5 Service Worker ç¼“å­˜ç­–ç•¥

```typescript
// public/sw.js

const CACHE_NAME = "algorithm-app-v1";
const STATIC_CACHE = "static-v1";
const DYNAMIC_CACHE = "dynamic-v1";

// é™æ€èµ„æº
const STATIC_ASSETS = [
  "/",
  "/problems",
  "/hooks",
  "/manifest.json",
  "/icons/icon-192.png",
  "/icons/icon-512.png",
];

// å®‰è£…
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      return cache.addAll(STATIC_ASSETS);
    })
  );
});

// æ¿€æ´»
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys
          .filter((key) => key !== STATIC_CACHE && key !== DYNAMIC_CACHE)
          .map((key) => caches.delete(key))
      );
    })
  );
});

// è¯·æ±‚æ‹¦æˆª
self.addEventListener("fetch", (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // API è¯·æ±‚ï¼šç½‘ç»œä¼˜å…ˆ
  if (url.pathname.startsWith("/api/")) {
    event.respondWith(networkFirst(request));
    return;
  }

  // é™æ€èµ„æºï¼šç¼“å­˜ä¼˜å…ˆ
  if (
    request.destination === "image" ||
    request.destination === "script" ||
    request.destination === "style"
  ) {
    event.respondWith(cacheFirst(request));
    return;
  }

  // é¡µé¢ï¼šStale While Revalidate
  event.respondWith(staleWhileRevalidate(request));
});

// ç¼“å­˜ä¼˜å…ˆç­–ç•¥
async function cacheFirst(request) {
  const cached = await caches.match(request);
  if (cached) return cached;

  const response = await fetch(request);
  const cache = await caches.open(STATIC_CACHE);
  cache.put(request, response.clone());
  return response;
}

// ç½‘ç»œä¼˜å…ˆç­–ç•¥
async function networkFirst(request) {
  try {
    const response = await fetch(request);
    const cache = await caches.open(DYNAMIC_CACHE);
    cache.put(request, response.clone());
    return response;
  } catch {
    return caches.match(request);
  }
}

// Stale While Revalidate
async function staleWhileRevalidate(request) {
  const cached = await caches.match(request);

  const fetchPromise = fetch(request).then((response) => {
    const cache = caches.open(DYNAMIC_CACHE);
    cache.then((c) => c.put(request, response.clone()));
    return response;
  });

  return cached || fetchPromise;
}
```

---

### 4.6 è¿”å›é¡¶éƒ¨ä¸æ»šåŠ¨è¿›åº¦

```tsx
// components/ui/ScrollProgress.tsx
"use client";

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

export function ScrollProgress() {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    const handleScroll = () => {
      const scrollTop = window.scrollY;
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
      setProgress(progress);
    };

    window.addEventListener("scroll", handleScroll, { passive: true });
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  return (
    <motion.div
      className="fixed top-0 left-0 right-0 h-1 bg-emerald-500 origin-left z-50"
      style={{ scaleX: progress / 100 }}
    />
  );
}

// è¿”å›é¡¶éƒ¨æŒ‰é’®
export function BackToTop() {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const handleScroll = () => {
      setIsVisible(window.scrollY > 400);
    };

    window.addEventListener("scroll", handleScroll, { passive: true });
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.button
          className="fixed bottom-24 right-4 z-40 w-12 h-12 rounded-full bg-zinc-800 border border-zinc-700 shadow-lg flex items-center justify-center hover:bg-zinc-700 active:scale-95 transition-all"
          initial={{ opacity: 0, scale: 0.8, y: 20 }}
          animate={{ opacity: 1, scale: 1, y: 0 }}
          exit={{ opacity: 0, scale: 0.8, y: 20 }}
          onClick={scrollToTop}
          whileHover={{ y: -2 }}
          whileTap={{ scale: 0.95 }}
        >
          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" />
          </svg>
        </motion.button>
      )}
    </AnimatePresence>
  );
}
```

---

## å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ä½“éªŒ (1-2 å‘¨)
- [ ] è§¦æ‘¸ç›®æ ‡å°ºå¯¸ä¼˜åŒ– (#1)
- [ ] ç‚¹å‡»åé¦ˆç³»ç»Ÿ (#2)
- [ ] è§¦æ‘¸å»¶è¿Ÿæ¶ˆé™¤ (#6)
- [ ] å®‰å…¨åŒºåŸŸé€‚é… (#41)
- [ ] éª¨æ¶å±ç»„ä»¶ (#55)

### ç¬¬äºŒé˜¶æ®µï¼šäº¤äº’å¢å¼º (2-3 å‘¨)
- [ ] å·¦æ»‘è¿”å›æ‰‹åŠ¿ (#16)
- [ ] ä¸‹æ‹‰åˆ·æ–° (#9)
- [ ] å…¨å±€æœç´¢ Cmd+K (#77)
- [ ] é¡µé¢è½¬åœºåŠ¨ç”» (#53)
- [ ] è™šæ‹Ÿåˆ—è¡¨ (#66)

### ç¬¬ä¸‰é˜¶æ®µï¼šå¹³å°ä¼˜åŒ– (2-3 å‘¨)
- [ ] iPad åˆ†å±é€‚é… (#29-31)
- [ ] é”®ç›˜å¿«æ·é”® (#32)
- [ ] Haptic åé¦ˆ (#50)
- [ ] æ·±è‰²æ¨¡å¼ä¼˜åŒ– (#45)
- [ ] Service Worker (#70)

### ç¬¬å››é˜¶æ®µï¼šç²¾ç»†æ‰“ç£¨ (1-2 å‘¨)
- [ ] æˆåŠŸåº†ç¥åŠ¨ç”» (#57)
- [ ] æ•°å­—æ»šåŠ¨åŠ¨ç”» (#60)
- [ ] å¾®äº¤äº’é›†åˆ (#93-100)
- [ ] é¢„åŠ è½½ä¼˜åŒ– (#69)
- [ ] æ€§èƒ½ç›‘æ§

---

## å‚è€ƒèµ„æº

- [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/)
- [Material Design 3](https://m3.material.io/)
- [Framer Motion](https://www.framer.com/motion/)
- [Web.dev æ€§èƒ½ä¼˜åŒ–](https://web.dev/performance/)
